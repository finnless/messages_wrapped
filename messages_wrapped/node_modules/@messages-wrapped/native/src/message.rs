use imessage_database::tables::messages::Message;
use imessage_database::util::streamtyped;
use imessage_database::util::typedstream::parser::TypedStreamReader;
use jiff::tz::TimeZone;
use jiff::{Timestamp, Zoned};
use rusqlite::{Params, Statement};

use crate::extensions::{GetIndex, GetRefIndex};
use crate::from_query::{FromQuery, FromQueryTable, QueryAll};
use crate::AnalyzerResult;

pub const EPOCH_DIFF: i64 = 978_307_200_000;

impl FromQuery for Message {
	/* src: https://docs.rs/imessage-database/latest/src/imessage_database/tables/messages/message.rs.html#108 */
	fn from_query<P>(stmt: &mut Statement<'_>, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		/* precompute the column indexes */
		let rowid_index = stmt.column_index("rowid");
		let guid_index = stmt.column_index("guid");
		let text_index = stmt.column_index("text");
		let handle_id_index = stmt.column_index("handle_id");
		let date_index = stmt.column_index("date");
		let is_from_me_index = stmt.column_index("is_from_me");
		let item_type_index = stmt.column_index("item_type");
		let associated_message_guid_index = stmt.column_index("associated_message_guid");
		let associated_message_type_index = stmt.column_index("associated_message_type");
		let chat_id_index = stmt.column_index("chat_id");
		let attributed_body_index = stmt.column_index("attributedBody");

		/* initialize output vector */
		let mut messages = Vec::new();

		/* see documentation https://docs.rs/rusqlite/latest/rusqlite/struct.Rows.html */
		let mut rows = stmt.query(params)?;

		while let Some(row) = rows.next()? {
			/* now call get on the rows, with the indexes precomputed */
			let mut message = Message {
				rowid: row.get_index(&rowid_index)?,
				guid: row.get_index(&guid_index)?,
				text: row.get_index(&text_index).unwrap_or(None),
				service: None,
				handle_id: row.get_index(&handle_id_index).unwrap_or(None),
				destination_caller_id: None,
				subject: None,
				date: row.get_index(&date_index)?,
				date_read: 0,
				date_delivered: 0,
				is_from_me: row.get_index(&is_from_me_index)?,
				is_read: false,
				item_type: row.get_index(&item_type_index).unwrap_or_default(),
				other_handle: 0,
				share_status: false,
				share_direction: false,
				group_title: None,
				group_action_type: 0,
				associated_message_guid: row
					.get_index(&associated_message_guid_index)
					.unwrap_or(None),
				associated_message_type: row
					.get_index(&associated_message_type_index)
					.unwrap_or(None),
				balloon_bundle_id: None,
				expressive_send_style_id: None,
				thread_originator_guid: None,
				thread_originator_part: None,
				date_edited: 0,
				associated_message_emoji: None,
				chat_id: row.get_index(&chat_id_index).unwrap_or(None),
				num_attachments: -1,
				deleted_from: None,
				num_replies: -1,
				components: None,
				edited_parts: None
			};

			let attributed_body = row
				.get_ref_index(&attributed_body_index)
				.map(|val| val.as_blob());

			if let Ok(Ok(body)) = attributed_body {
				let mut typedstream = TypedStreamReader::from(body);

				message.components = typedstream.parse().ok();

				// If we deserialize the typedstream, use that data
				message.text = message
					.components
					.as_ref()
					.and_then(|items| items.first())
					.and_then(|item| item.as_nsstring())
					.map(String::from);

				// If the above parsing failed, fall back to the legacy parser instead
				if message.text.is_none() {
					message.text = streamtyped::parse(body.to_vec()).ok();
				}
			}

			messages.push(message);
		}

		Ok(messages)
	}
}

// #[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord)]
// pub enum Direction {
// 	Sent,
// 	Received
// }

pub trait MessageExt {
	fn time(&self) -> Zoned;
	fn format_date(&self) -> String;
	// fn direction(&self) -> Direction;
}

impl MessageExt for Message {
	fn time(&self) -> Zoned {
		let ms = (self.date / 1_000_000) + EPOCH_DIFF; // self.date is in nanoseconds
		Timestamp::from_millisecond(ms)
			.unwrap()
			.to_zoned(TimeZone::system())
	}

	fn format_date(&self) -> String {
		let zoned = self.time();
		format!(
			"{:04}-{:02}-{:02}",
			zoned.year(),
			zoned.month(),
			zoned.day()
		)
	}

	// fn direction(&self) -> Direction {
	// 	if self.is_from_me {
	// 		Direction::Sent
	// 	} else {
	// 		Direction::Received
	// 	}
	// }
}

pub trait ZonedExt {
	fn day_of_the_week(&self) -> i32;
}

impl ZonedExt for Zoned {
	fn day_of_the_week(&self) -> i32 {
		self.weekday().to_monday_zero_offset() as i32
	}
}

impl FromQueryTable for Message {
	fn from_query_tbl<P>(stmt: &mut Statement<'_>, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		Self::from_query(stmt, params)
	}
}

impl QueryAll for Message {
	fn query_all<P>(db: &rusqlite::Connection, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		let mut stmt = db.prepare(
			"SELECT
				m.rowid, m.guid, m.text, m.handle_id, m.date, m.date_delivered, 
				m.is_from_me, m.is_read, m.item_type, m.associated_message_guid, 
				m.associated_message_type, m.attributedBody,
				c.chat_id
			FROM
				message as m
			LEFT JOIN chat_message_join as c ON m.ROWID = c.message_id"
		)?;

		Self::from_query_tbl(&mut stmt, params)
	}
}
