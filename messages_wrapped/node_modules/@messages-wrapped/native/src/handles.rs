use std::collections::HashMap;

use phonenumber::country::Id;
use phonenumber::Mode;
use rusqlite::{Connection, Params, Statement};

use crate::contacts::Contacts;
use crate::from_query::{FromQuery, QueryAll};
use crate::AnalyzerResult;

#[derive(Debug, Clone)]
pub struct Handle {
	pub rowid: i64,
	pub id: String,            // Original ID (phone/email/etc)
	pub normalized_id: String, // Normalized version for matching
	pub service: Option<String>,
	pub uncanonicalized_id: Option<String>
}

struct ChatHandleAssociation {
	pub chat_id: i32,
	pub handle_id: i64
}

impl Handle {
	fn get_query(conn: &Connection) -> AnalyzerResult<Statement<'_>> {
		Ok(conn.prepare(
			"SELECT 
				handle.ROWID as handle_id,
				handle.id,
				handle.service,
				handle.uncanonicalized_id
			FROM handle"
		)?)
	}

	fn normalize_phone(phone: &str) -> String {
		let parsed =
			phonenumber::parse(Some(Id::US), phone).or_else(|_| phonenumber::parse(None, phone));

		match parsed {
			Ok(number) if phonenumber::is_valid(&number) => {
				number.format().mode(Mode::E164).to_string()
			}
			_ => Contacts::normalize_id(phone) // Fall back to basic normalization
		}
	}
}

impl ChatHandleAssociation {
	fn get_query(conn: &Connection) -> AnalyzerResult<Statement<'_>> {
		Ok(conn.prepare("SELECT chat_id, handle_id FROM chat_handle_join")?)
	}
}

impl FromQuery for ChatHandleAssociation {
	fn from_query<P>(stmt: &mut Statement<'_>, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		let mut associations = Vec::new();
		let mut rows = stmt.query(params)?;

		while let Some(row) = rows.next()? {
			associations.push(Self {
				chat_id: row.get("chat_id")?,
				handle_id: row.get("handle_id")?
			});
		}

		Ok(associations)
	}
}

impl QueryAll for ChatHandleAssociation {
	fn query_all<P>(db: &Connection, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		Self::from_query(&mut Self::get_query(db)?, params)
	}
}
#[derive(Debug, Clone)]
pub struct ChatInfo {
	pub rowid: i32,
	pub display_name: Option<String>,
	pub chat_identifier: Option<String>
}

impl ChatInfo {
	fn get_query(conn: &Connection) -> AnalyzerResult<Statement<'_>> {
		Ok(conn.prepare(
			"SELECT 
                ROWID as chat_id,
                display_name,
                chat_identifier
            FROM chat"
		)?)
	}
}

impl FromQuery for ChatInfo {
	fn from_query<P>(stmt: &mut Statement<'_>, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		let mut chats = Vec::new();
		let mut rows = stmt.query(params)?;

		while let Some(row) = rows.next()? {
			chats.push(ChatInfo {
				rowid: row.get("chat_id")?,
				display_name: row.get("display_name")?,
				chat_identifier: row.get("chat_identifier")?
			});
		}

		Ok(chats)
	}
}

impl QueryAll for ChatInfo {
	fn query_all<P>(db: &Connection, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		Self::from_query(&mut Self::get_query(db)?, params)
	}
}

pub struct Handles {
	chat_handles: HashMap<i32, Vec<Handle>>,
	chat_info: HashMap<i32, ChatInfo>
}

impl Handles {
	pub fn new(conn: &Connection) -> AnalyzerResult<Self> {
		let mut by_id = HashMap::new();
		let mut chat_handles = HashMap::new();
		let mut chat_info = HashMap::new();

		let handle_rows = Handle::query_all(conn, [])?;

		for handle in handle_rows {
			by_id.insert(handle.rowid, handle);
		}

		let associations = ChatHandleAssociation::query_all(conn, [])?;

		for association in associations {
			chat_handles
				.entry(association.chat_id)
				.or_insert_with(Vec::new)
				.push(by_id.get(&association.handle_id).unwrap().clone());
		}

		let chat_info_rows = ChatInfo::query_all(conn, [])?;

		for chat_i in chat_info_rows {
			chat_info.insert(chat_i.rowid, chat_i);
		}

		Ok(Self { chat_handles, chat_info })
	}

	pub fn get_chat_handles(&self, chat_id: i32) -> Option<&Vec<Handle>> {
		self.chat_handles.get(&chat_id)
	}

	pub fn is_group_chat(&self, chat_id: i32) -> bool {
		self.chat_handles
			.get(&chat_id)
			.is_some_and(|handles| handles.len() > 1)
	}

	pub fn get_chat_info(&self, chat_id: i32) -> Option<&ChatInfo> {
		self.chat_info.get(&chat_id)
	}

	pub fn get_chat_name(&self, chat_id: i32, contacts: &Contacts) -> String {
		// For group chats, try display name first
		if self.is_group_chat(chat_id) {
			if let Some(info) = self.get_chat_info(chat_id) {
				if let Some(display_name) = &info.display_name {
					if !display_name.is_empty() {
						return display_name.clone();
					}
				}
			}
		}

		// Get contact names for both group and individual chats
		let contact_names = self.get_chat_handles(chat_id).map(|handles| {
			let mut names = Vec::new();
			for handle in handles {
				if let Some(contact) = contacts.lookup(&handle.normalized_id) {
					names.push(contact.display_name.clone());
				} else {
					names.push(handle.id.clone());
				}
			}
			names.dedup();
			names
		});

		// Use contact names if available
		if let Some(names) = contact_names {
			if !names.is_empty() {
				return names.join(", ");
			}
		}

		// Fallback to chat identifier or chat ID
		self.get_chat_info(chat_id)
			.and_then(|info| info.chat_identifier.clone())
			.unwrap_or_else(|| format!("Chat {}", chat_id))
	}
}

impl FromQuery for Handle {
	fn from_query<P>(stmt: &mut Statement<'_>, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		let mut handles = Vec::new();

		let mut rows = stmt.query(params)?;

		while let Some(row) = rows.next()? {
			let id: String = row.get("id")?;
			let service: Option<String> = row.get("service")?;

			// Normalize the ID based on type
			let normalized_id = if id.contains('@') {
				// Email address
				id.to_lowercase()
			} else if service == Some("SMS".to_string()) {
				// Phone number
				Self::normalize_phone(&id)
			} else {
				// Other ID types
				id.clone()
			};

			handles.push(Handle {
				rowid: row.get("handle_id")?,
				id,
				normalized_id,
				service,
				uncanonicalized_id: row.get("uncanonicalized_id")?
			});
		}

		Ok(handles)
	}
}

impl QueryAll for Handle {
	fn query_all<P>(db: &Connection, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		Self::from_query(&mut Self::get_query(db)?, params)
	}
}
