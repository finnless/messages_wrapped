use std::fs;
use std::io::ErrorKind;
use std::path::Path;
use std::time::SystemTime;

use imessage_database::tables::table::get_connection;
use rusqlite::{Connection, OpenFlags};

use crate::{AnalyzerError, AnalyzerResult};

#[allow(unsafe_code, reason = "initialize the sqlite library")]
pub fn init_sqlite() {
	/* manual init and shutdown for extra speed */
	let init_res = unsafe { libsqlite3_sys::sqlite3_initialize() };
	assert_eq!(init_res, libsqlite3_sys::SQLITE_OK);

	/* use singlethreaded mode */
	unsafe { libsqlite3_sys::sqlite3_config(libsqlite3_sys::SQLITE_CONFIG_SINGLETHREAD) };
}

#[allow(unsafe_code, reason = "shutdown the sqlite library")]
pub fn shutdown_sqlite() {
	unsafe { libsqlite3_sys::sqlite3_shutdown() };
}

pub fn get_chat_db_connection<P>(path: P) -> AnalyzerResult<Connection>
where
	P: AsRef<Path>
{
	Ok(get_connection(path.as_ref())?)
}

pub fn get_address_book_db_connections<P>(path: P) -> AnalyzerResult<Vec<Connection>>
where
	P: AsRef<Path>
{
	let root_path = path.as_ref();
	let mut db_paths = Vec::new();

	let entries = match fs::read_dir(root_path) {
		Ok(entries) => Some(entries),
		Err(err) if err.kind() == ErrorKind::NotFound => None,
		Err(err) => return Err(AnalyzerError::Io(err))
	};

	for entry in entries.into_iter().flatten().flatten() {
		if let Ok(Some(modified)) = get_file_modified_time_if_address_db(&entry) {
			db_paths.push((entry.path(), modified));
		}
	}

	let entries = match fs::read_dir(root_path.join("Sources")) {
		Ok(entries) => Some(entries),
		Err(err) if err.kind() == ErrorKind::NotFound => None,
		Err(err) => return Err(AnalyzerError::Io(err))
	};

	for dir in entries
		.into_iter()
		.flatten()
		.flatten()
		.filter(|e| e.path().is_dir())
	{
		let subentries = match fs::read_dir(dir.path()) {
			Ok(entries) => Some(entries),
			Err(err) if err.kind() == ErrorKind::NotFound => None,
			Err(err) => return Err(AnalyzerError::Io(err))
		};

		for entry in subentries.into_iter().flatten().flatten() {
			if let Ok(Some(modified)) = get_file_modified_time_if_address_db(&entry) {
				db_paths.push((entry.path(), modified));
			}
		}
	}

	if db_paths.is_empty() {
		return Err(AnalyzerError::Io(std::io::Error::new(
			ErrorKind::NotFound,
			"No AddressBook database found"
		)));
	}

	// Sort by modified time, oldest first
	db_paths.sort_by(|(_, a), (_, b)| a.cmp(b));

	let mut connections = Vec::new();
	for (db_path, _) in &db_paths {
		match Connection::open_with_flags(db_path, OpenFlags::SQLITE_OPEN_READ_ONLY) {
			Ok(conn) => connections.push(conn),
			Err(e) => println!(
				"Warning: Failed to open database at {}: {}",
				db_path.display(),
				e
			)
		}
	}

	if connections.is_empty() {
		return Err(AnalyzerError::Io(std::io::Error::new(
			ErrorKind::NotFound,
			"Failed to open any AddressBook databases"
		)));
	}

	Ok(connections)
}

fn get_file_modified_time_if_address_db(
	entry: &fs::DirEntry
) -> std::io::Result<Option<SystemTime>> {
	Ok(if entry.file_name() == "AddressBook-v22.abcddb" {
		Some(entry.metadata()?.modified()?)
	} else {
		None
	})
}
