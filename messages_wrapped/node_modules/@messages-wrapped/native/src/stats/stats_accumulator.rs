use std::cell::RefCell;
use std::collections::{HashMap, HashSet};
use std::time::{Duration, Instant};

use imessage_database::tables::messages::Message;
use jiff::tz::TimeZone;
use jiff::Timestamp;
use regex::Regex;

use super::stats::*;
use crate::contacts::{Contact, Contacts};
use crate::handles::Handles;
use crate::message::{MessageExt, ZonedExt, EPOCH_DIFF};
use crate::stats::utils::slurs::is_slur;
use crate::stats::utils::stop_words::is_stop_word;
use crate::StatsGenerationTiming;

#[derive(Debug, Clone, serde::Serialize)]
pub struct DownBadStats {
	pub sent: i32,
	pub received: i32
}

#[derive(Debug, Clone, serde::Serialize)]
pub struct RawChats {
	pub chat_id: i32,
	pub name: String,
	pub sent: i32,
	pub received: i32,
	pub is_group_chat: bool,
	pub down_bad_stats: DownBadStats,
	pub avatar: Option<Vec<u8>>
}

type WordMap = HashMap<String, u32>;
type DirectionalCount = (WordMap, WordMap);
type YearlyWordCounts = HashMap<i32, DirectionalCount>;
type ReactionDetail = (String, i32, ReactionCounts);
type YearlyReactions = HashMap<i32, HashMap<String, ReactionDetail>>;

type ReactionCount = HashMap<String, i32>;
type MessageDetails = HashMap<String, (String, i32)>;
type YearlyReactionCounts = HashMap<i32, ReactionCount>;
type YearlyMessageDetails = HashMap<i32, MessageDetails>;

type ChatStats = HashMap<i32, RawChats>;
type YearlyChatStats = HashMap<i32, ChatStats>;

type LastMessage = HashMap<i32, (i64, bool)>;
type YearlyLastMessages = HashMap<i32, LastMessage>;
type LeftOnReadStats = HashMap<i32, (i32, i32)>;
type YearlyLeftOnRead = HashMap<i32, LeftOnReadStats>;

type TextingSession = (i64, i64, String, i32);

pub struct StatsAccumulator {
	pub yearly_counts: HashMap<i32, MessageCount>,
	pub monthly_stats: HashMap<i32, Vec<MessageCount>>,
	pub weekday_stats: HashMap<i32, Vec<MessageCount>>,
	pub hourly_stats: HashMap<i32, Vec<MessageCount>>,

	pub word_counts: YearlyWordCounts,
	pub emoji_counts: YearlyWordCounts,

	pub emoji_regex: Regex,
	pub non_letters_regex: Regex,

	pub reaction_details: YearlyReactions,

	pub most_sent: HashMap<i32, HashMap<String, i32>>,

	pub reaction_counts: YearlyReactionCounts,

	pub message_details: YearlyMessageDetails,

	pub timings: RefCell<StatsGenerationTiming>,

	pub chat_stats: YearlyChatStats,

	pub last_messages: YearlyLastMessages,
	pub left_on_read_stats: YearlyLeftOnRead,

	pub first_message_dates: HashMap<i32, i32>,
	pub last_message_dates: HashMap<i32, i32>,
	pub message_counts: HashMap<i32, MessageCount>,

	pub character_counts: HashMap<i32, MessageCount>,

	pub slur_counts: HashMap<i32, HashMap<String, i32>>,

	pub response_time_stats: HashMap<i32, HashMap<String, (i64, i32)>>,
	pub last_sent_message: HashMap<i32, HashMap<i32, i64>>,
	pub longest_messages: HashMap<i32, HashMap<String, (String, usize)>>,

	pub hater_stats: HashMap<i32, HashMap<String, i32>>,
	pub glazer_stats: HashMap<i32, HashMap<String, i32>>,

	pub favor_stats: HashMap<i32, HashMap<String, i32>>,
	pub freaky_stats: HashMap<i32, HashMap<String, i32>>,

	pub double_text_stats: HashMap<i32, HashMap<String, i32>>,
	pub last_message_times: HashMap<i32, HashMap<i32, (i64, String, bool)>>,

	pub texting_sessions: HashMap<i32, HashMap<String, TextingSession>>,

	pub group_chat_slur_stats: HashMap<i32, HashMap<i32, HashMap<String, i32>>>,

	pub send_received_ratios: HashMap<i32, HashMap<i32, (i32, i32)>>,

	pub realest_stats: HashMap<i32, HashMap<String, i32>>
}

trait ReactionMessageExt {
	fn is_reaction_to_my_message(&self, accumulator: &StatsAccumulator) -> bool;
}

impl ReactionMessageExt for Message {
	fn is_reaction_to_my_message(&self, accumulator: &StatsAccumulator) -> bool {
		if !self.is_tapback() {
			return false;
		}

		let Some(original_guid) = &self.associated_message_guid else {
			return false;
		};

		let original_guid = original_guid.strip_prefix("p:0/").unwrap_or(original_guid);

		accumulator
			.message_details
			.values()
			.any(|details| details.contains_key(original_guid))
	}
}

impl StatsAccumulator {
	pub fn new() -> Self {
		Self {
			yearly_counts: HashMap::new(),
			monthly_stats: HashMap::new(),
			weekday_stats: HashMap::new(),
			hourly_stats: HashMap::new(),
			word_counts: HashMap::new(),
			emoji_counts: HashMap::new(),
			emoji_regex: Regex::new(r"\p{Extended_Pictographic}").unwrap(),
			non_letters_regex: Regex::new(r"[^a-z\s]").unwrap(),
			reaction_details: HashMap::new(),
			most_sent: HashMap::new(),
			reaction_counts: HashMap::new(),
			message_details: HashMap::new(),
			timings: RefCell::new(StatsGenerationTiming {
				year_time: Duration::default(),
				month_time: Duration::default(),
				weekday_time: Duration::default(),
				hour_time: Duration::default(),
				top_sent_time: Duration::default(),
				words_emoji_time: Duration::default(),
				messages_per_day_time: Duration::default(),
				message_length_time: Duration::default(),
				reactions_time: Duration::default(),
				response_time: Duration::default(),
				chat_stats_time: Duration::default(),
				left_on_read_time: Duration::default(),
				slurs_time: Duration::default(),
				reactionner_time: Duration::default(),
				favor_time: Duration::default(),
				freaky_time: Duration::default(),
				double_text_time: Duration::default(),
				session_time: Duration::default(),
				group_chat_slurs_time: Duration::default(),
				send_received_ratio_time: Duration::default(),
				total_time: Duration::default(),
				realest_time: Duration::default()
			}),
			chat_stats: HashMap::new(),
			last_messages: HashMap::new(),
			left_on_read_stats: HashMap::new(),
			first_message_dates: HashMap::new(),
			last_message_dates: HashMap::new(),
			message_counts: HashMap::new(),
			character_counts: HashMap::new(),
			slur_counts: HashMap::new(),
			response_time_stats: HashMap::new(),
			last_sent_message: HashMap::new(),
			longest_messages: HashMap::new(),
			hater_stats: HashMap::new(),
			glazer_stats: HashMap::new(),
			favor_stats: HashMap::new(),
			freaky_stats: HashMap::new(),
			double_text_stats: HashMap::new(),
			last_message_times: HashMap::new(),
			texting_sessions: HashMap::new(),
			group_chat_slur_stats: HashMap::new(),
			send_received_ratios: HashMap::new(),
			realest_stats: HashMap::new()
		}
	}

	pub fn process_message(&mut self, message: &Message, handles: &Handles, contacts: &Contacts) {
		let start = Instant::now();

		let year = message.time().year() as i32;

		let count_start = Instant::now();
		self.update_yearly_count(year, message);
		self.timings.borrow_mut().year_time += count_start.elapsed();

		let monthly_start = Instant::now();
		self.update_monthly_stats(year, message);
		self.timings.borrow_mut().month_time += monthly_start.elapsed();

		let weekday_start = Instant::now();
		self.update_weekday_stats(year, message);
		self.timings.borrow_mut().weekday_time += weekday_start.elapsed();

		let hourly_start = Instant::now();
		self.update_hourly_stats(year, message);
		self.timings.borrow_mut().hour_time += hourly_start.elapsed();

		let most_sent_start = Instant::now();
		self.update_most_sent(year, message);
		self.timings.borrow_mut().top_sent_time += most_sent_start.elapsed();

		let words_start = Instant::now();
		if let Some(text) = &message.text {
			if !text.is_empty() {
				self.update_word_and_emoji_counts(year, message);
			}
		}
		self.timings.borrow_mut().words_emoji_time += words_start.elapsed();

		let response_time_start = Instant::now();
		self.update_response_times(year, message, handles);
		self.timings.borrow_mut().response_time += response_time_start.elapsed();

		let reactions_start = Instant::now();
		self.update_reaction_stats(year, message);
		self.timings.borrow_mut().reactions_time += reactions_start.elapsed();

		let reactionner_start = Instant::now();
		self.update_reactionner_stats(year, message, handles);
		self.timings.borrow_mut().reactionner_time += reactionner_start.elapsed();

		let chat_start = Instant::now();
		self.update_chat_stats(year, message, handles, contacts);
		self.timings.borrow_mut().chat_stats_time += chat_start.elapsed();

		let left_read_start = Instant::now();
		self.update_left_on_read(year, message, handles);
		self.timings.borrow_mut().left_on_read_time += left_read_start.elapsed();

		let messages_per_day_start = Instant::now();
		self.update_message_averages(year, message);
		self.timings.borrow_mut().messages_per_day_time += messages_per_day_start.elapsed();

		let character_count_start = Instant::now();
		self.update_character_counts(year, message);
		self.timings.borrow_mut().message_length_time += character_count_start.elapsed();

		let slurs_start = Instant::now();
		if !message.is_from_me {
			if let Some(text) = &message.text {
				if !text.is_empty() {
					self.update_slur_counts(year, message, handles);
					let group_chat_start = Instant::now();
					self.update_group_chat_slur_counts(year, message, handles);
					self.timings.borrow_mut().group_chat_slurs_time += group_chat_start.elapsed();
				}
			}
		}
		self.timings.borrow_mut().slurs_time += slurs_start.elapsed();

		let longest_message_start = Instant::now();
		self.update_longest_message(year, message, handles);
		self.timings.borrow_mut().message_length_time += longest_message_start.elapsed();

		let favor_start = Instant::now();
		StatsAccumulator::update_phrase_stats(
			&mut self.favor_stats,
			year,
			message,
			handles,
			crate::stats::utils::favor_phrases::is_favor_phrase
		);
		self.timings.borrow_mut().favor_time += favor_start.elapsed();

		let freaky_start = Instant::now();
		StatsAccumulator::update_phrase_stats(
			&mut self.freaky_stats,
			year,
			message,
			handles,
			crate::stats::utils::freaky_phrases::is_freaky_phrase
		);
		self.timings.borrow_mut().freaky_time += freaky_start.elapsed();

		let double_text_start = Instant::now();
		self.update_double_text_stats(year, message, handles);
		self.timings.borrow_mut().double_text_time += double_text_start.elapsed();

		let chat_start = Instant::now();
		self.update_send_received_ratio(year, message, handles);
		self.timings.borrow_mut().send_received_ratio_time += chat_start.elapsed();

		let realest_start = Instant::now();
		StatsAccumulator::update_phrase_stats(
			&mut self.realest_stats,
			year,
			message,
			handles,
			crate::stats::utils::realest_phrases::is_realest_phrase
		);
		self.timings.borrow_mut().realest_time += realest_start.elapsed();

		self.timings.borrow_mut().total_time += start.elapsed();
	}

	fn update_yearly_count(&mut self, year: i32, message: &Message) {
		let year_stats = self.yearly_counts.entry(year).or_default();
		if message.is_from_me {
			year_stats.sent += 1;
		} else {
			year_stats.received += 1;
		}

		if year != 0 {
			let all_time_stats = self.yearly_counts.entry(0).or_default();
			if message.is_from_me {
				all_time_stats.sent += 1;
			} else {
				all_time_stats.received += 1;
			}
		}
	}

	fn update_monthly_stats(&mut self, year: i32, message: &Message) {
		let monthly = self
			.monthly_stats
			.entry(year)
			.or_insert_with(|| vec![MessageCount::default(); 12]);

		let month_index = (message.time().month() - 1) as usize;

		if message.is_from_me {
			monthly[month_index].sent += 1;
		} else {
			monthly[month_index].received += 1;
		}

		if year != 0 {
			let all_time = self
				.monthly_stats
				.entry(0)
				.or_insert_with(|| vec![MessageCount::default(); 12]);
			if message.is_from_me {
				all_time[month_index].sent += 1;
			} else {
				all_time[month_index].received += 1;
			}
		}
	}

	fn update_weekday_stats(&mut self, year: i32, message: &Message) {
		let weekday = self
			.weekday_stats
			.entry(year)
			.or_insert_with(|| vec![MessageCount::default(); 7]);

		let day_index = message.time().day_of_the_week() as usize;

		if message.is_from_me {
			weekday[day_index].sent += 1;
		} else {
			weekday[day_index].received += 1;
		}

		if year != 0 {
			let all_time = self
				.weekday_stats
				.entry(0)
				.or_insert_with(|| vec![MessageCount::default(); 7]);
			if message.is_from_me {
				all_time[day_index].sent += 1;
			} else {
				all_time[day_index].received += 1;
			}
		}
	}

	fn update_hourly_stats(&mut self, year: i32, message: &Message) {
		let hourly = self
			.hourly_stats
			.entry(year)
			.or_insert_with(|| vec![MessageCount::default(); 24]);

		let hour_index = message.time().hour() as usize;

		if message.is_from_me {
			hourly[hour_index].sent += 1;
		} else {
			hourly[hour_index].received += 1;
		}

		if year != 0 {
			let all_time = self
				.hourly_stats
				.entry(0)
				.or_insert_with(|| vec![MessageCount::default(); 24]);
			if message.is_from_me {
				all_time[hour_index].sent += 1;
			} else {
				all_time[hour_index].received += 1;
			}
		}
	}

	fn update_word_and_emoji_counts(&mut self, year: i32, message: &Message) {
		let Some(text) = &message.text else { return };
		if message.associated_message_type != Some(0) {
			return;
		};

		let (word_maps, emoji_maps) = {
			let word_maps = self
				.word_counts
				.entry(year)
				.or_insert_with(|| (HashMap::new(), HashMap::new()));
			let emoji_maps = self
				.emoji_counts
				.entry(year)
				.or_insert_with(|| (HashMap::new(), HashMap::new()));
			(word_maps, emoji_maps)
		};

		let (word_map, emoji_map) = if message.is_from_me {
			(&mut word_maps.0, &mut emoji_maps.0)
		} else {
			(&mut word_maps.1, &mut emoji_maps.1)
		};

		for emoji in self.emoji_regex.find_iter(text) {
			*emoji_map.entry(emoji.as_str().to_string()).or_insert(0) += 1;
		}

		let lowercase_text = text.to_lowercase();
		let cleaned_text = self.non_letters_regex.replace_all(&lowercase_text, "");
		for word in cleaned_text.split_whitespace() {
			if !word.is_empty() && !is_stop_word(word) {
				*word_map.entry(word.to_string()).or_insert(0) += 1;
			}
		}

		if year != 0 {
			self.update_word_and_emoji_counts(0, message);
		}
	}

	fn update_reaction_stats(&mut self, year: i32, message: &Message) {
		if let Some(text) = &message.text {
			if !text.is_empty() && !text.contains('\u{fffc}') && message.is_from_me {
				let year_details = self.message_details.entry(year).or_default();
				year_details.insert(
					message.guid.clone(),
					(text.clone(), message.chat_id.unwrap_or(0))
				);

				if year != 0 {
					let all_time = self.message_details.entry(0).or_default();
					all_time.insert(
						message.guid.clone(),
						(text.clone(), message.chat_id.unwrap_or(0))
					);
				}
			}
		}

		if !message.is_tapback() {
			return;
		}

		let (Some(reaction_type), Some(original_guid)) = (
			message.associated_message_type,
			&message.associated_message_guid
		) else {
			return;
		};

		let original_guid = original_guid.strip_prefix("p:0/").unwrap_or(original_guid);

		if !self
			.message_details
			.values()
			.any(|details| details.contains_key(original_guid))
		{
			return;
		}

		let year_counts = self.reaction_counts.entry(year).or_default();
		*year_counts.entry(original_guid.to_string()).or_default() += 1;

		let year_details = self.reaction_details.entry(year).or_default();
		let detail = year_details
			.entry(original_guid.to_string())
			.or_insert_with(|| (String::new(), 0, ReactionCounts::default()));

		let counts = &mut detail.2;
		match reaction_type {
			2000 => counts.loved += 1,
			2001 => counts.liked += 1,
			2002 => counts.disliked += 1,
			2003 => counts.laughed += 1,
			2004 => counts.emphasized += 1,
			2005 => counts.questioned += 1,
			_ => {}
		}

		if year != 0 {
			self.update_reaction_stats(0, message);
		}
	}

	fn update_reactionner_stats(&mut self, year: i32, message: &Message, handles: &Handles) {
		if !message.is_reaction_to_my_message(self) {
			return;
		}

		let Some(reaction_type) = message.associated_message_type else {
			return;
		};
		let Some(handle_id) = message.handle_id else {
			return;
		};

		if let Some(handles_list) = handles.get_chat_handles(message.chat_id.unwrap_or(0)) {
			if let Some(handle) = handles_list.iter().find(|h| h.rowid == handle_id as i64) {
				if reaction_type == 2002 || reaction_type == 2005 {
					let year_stats = self.hater_stats.entry(year).or_default();
					*year_stats.entry(handle.normalized_id.clone()).or_default() += 1;

					if year != 0 {
						let all_time = self.hater_stats.entry(0).or_default();
						*all_time.entry(handle.normalized_id.clone()).or_default() += 1;
					}
				} else if reaction_type == 2000 || reaction_type == 2003 || reaction_type == 2004 {
					let year_stats = self.glazer_stats.entry(year).or_default();
					*year_stats.entry(handle.normalized_id.clone()).or_default() += 1;

					if year != 0 {
						let all_time = self.glazer_stats.entry(0).or_default();
						*all_time.entry(handle.normalized_id.clone()).or_default() += 1;
					}
				}
			}
		}
	}

	fn update_most_sent(&mut self, year: i32, message: &Message) {
		let Some(text) = &message.text else { return };

		if text.is_empty() ||
			!message.is_from_me ||
			message.associated_message_type != Some(0) ||
			message.item_type != 0
		{
			return;
		}

		let text = text.to_lowercase();
		if is_stop_word(&text) {
			return;
		}

		let year_stats = self.most_sent.entry(year).or_default();
		*year_stats.entry(text.clone()).or_default() += 1;

		if year != 0 {
			let all_time = self.most_sent.entry(0).or_default();
			*all_time.entry(text).or_default() += 1;
		}
	}

	fn update_chat_stats(
		&mut self, year: i32, message: &Message, handles: &Handles, contacts: &Contacts
	) {
		let Some(chat_id) = message.chat_id else {
			return;
		};

		let hour = message.time().hour();
		let is_down_bad_hour = (0..=4).contains(&hour);

		let year_stats = self.chat_stats.entry(year).or_default();
		let raw_chat = year_stats.entry(chat_id).or_insert_with(|| {
			let is_group = handles.is_group_chat(chat_id);
			let avatar = if !is_group {
				handles
					.get_chat_handles(chat_id)
					.and_then(|handles| handles.first())
					.and_then(|handle| contacts.lookup(&handle.normalized_id))
					.and_then(|contact| contact.avatar.clone())
			} else {
				None
			};

			RawChats {
				chat_id,
				name: handles.get_chat_name(chat_id, contacts),
				sent: 0,
				received: 0,
				is_group_chat: is_group,
				down_bad_stats: DownBadStats { sent: 0, received: 0 },
				avatar
			}
		});

		if message.is_from_me {
			raw_chat.sent += 1;
			if is_down_bad_hour {
				raw_chat.down_bad_stats.sent += 1;
			}
		} else {
			raw_chat.received += 1;
			if is_down_bad_hour {
				raw_chat.down_bad_stats.received += 1;
			}
		}

		if year != 0 {
			self.update_chat_stats(0, message, handles, contacts);
		}
	}

	fn update_left_on_read(&mut self, year: i32, message: &Message, handles: &Handles) {
		let Some(chat_id) = message.chat_id else {
			return;
		};
		if message.text.as_ref().map_or(true, String::is_empty) {
			return;
		};
		if handles.is_group_chat(chat_id) {
			return;
		};

		let two_days_ns = 2 * 24 * 60 * 60 * 1_000_000_000i64;

		let last_messages = self.last_messages.entry(year).or_default();
		if let Some((last_time, last_from_me)) = last_messages.get(&chat_id) {
			let time_diff = message.date - last_time;
			if time_diff > two_days_ns {
				let stats = self.left_on_read_stats.entry(year).or_default();
				let (left, ignored) = stats.entry(chat_id).or_insert((0, 0));

				if !last_from_me && message.is_from_me {
					*left += 1;
				} else if *last_from_me && !message.is_from_me {
					*ignored += 1;
				}
			}
		}

		last_messages.insert(chat_id, (message.date, message.is_from_me));

		if year != 0 {
			self.update_left_on_read(0, message, handles);
		}
	}

	fn update_message_averages(&mut self, year: i32, message: &Message) {
		let Some(text) = &message.text else { return };
		if text.is_empty() {
			return;
		};

		let ms = message.time().millisecond() as i32;

		let first_date = self.first_message_dates.entry(year).or_insert(ms);
		if ms < *first_date {
			*first_date = ms;
		}

		let last_date = self.last_message_dates.entry(year).or_insert(ms);
		if ms > *last_date {
			*last_date = ms;
		}

		let counts = self.message_counts.entry(year).or_default();
		if message.is_from_me {
			counts.sent += 1;
		} else {
			counts.received += 1;
		}

		if year != 0 {
			self.update_message_averages(0, message);
		}
	}

	fn update_character_counts(&mut self, year: i32, message: &Message) {
		let Some(text) = &message.text else { return };
		if text.is_empty() {
			return;
		};

		let counts = self.character_counts.entry(year).or_default();
		if message.is_from_me {
			counts.sent += text.len() as i32;
		} else {
			counts.received += text.len() as i32;
		}

		if year != 0 {
			self.update_character_counts(0, message);
		}
	}

	fn update_slur_counts(&mut self, year: i32, message: &Message, handles: &Handles) {
		if message.is_from_me {
			return;
		}

		let Some(text) = &message.text else { return };
		let Some(handle_id) = message.handle_id else {
			return;
		};
		let Some(chat_id) = message.chat_id else {
			return;
		};

		let contains_slur = text.split_whitespace().any(is_slur);

		if contains_slur {
			if let Some(handles_list) = handles.get_chat_handles(chat_id) {
				if let Some(handle) = handles_list.iter().find(|h| h.rowid == handle_id as i64) {
					let year_counts = self.slur_counts.entry(year).or_default();
					*year_counts.entry(handle.normalized_id.clone()).or_default() += 1;

					if year != 0 {
						let all_time = self.slur_counts.entry(0).or_default();
						*all_time.entry(handle.normalized_id.clone()).or_default() += 1;
					}
				}
			}
		}
	}

	fn update_response_times(&mut self, year: i32, message: &Message, handles: &Handles) {
		let Some(chat_id) = message.chat_id else {
			return;
		};
		if handles.is_group_chat(chat_id) {
			return;
		};

		let two_days_ns = 2 * 24 * 60 * 60 * 1_000_000_000i64;

		let year_last_sent = self.last_sent_message.entry(year).or_default();

		if !message.is_from_me {
			if let Some(&last_sent_time) = year_last_sent.get(&chat_id) {
				let response_time = message.date - last_sent_time;

				if response_time > 0 && response_time < two_days_ns {
					let response_time_secs = response_time / 1_000_000_000;

					if let Some(handle_id) = message.handle_id {
						if let Some(handles_list) = handles.get_chat_handles(chat_id) {
							if let Some(handle) =
								handles_list.iter().find(|h| h.rowid == handle_id as i64)
							{
								let year_stats = self.response_time_stats.entry(year).or_default();
								let (total_time, count) = year_stats
									.entry(handle.normalized_id.clone())
									.or_insert((0, 0));
								*total_time += response_time_secs;
								*count += 1;
							}
						}
					}
				}
			}
		} else {
			year_last_sent.insert(chat_id, message.date);
		}

		if year != 0 {
			self.update_response_times(0, message, handles);
		}
	}

	fn update_longest_message(&mut self, year: i32, message: &Message, handles: &Handles) {
		if message.is_from_me {
			return;
		}

		let Some(text) = &message.text else { return };
		if text.is_empty() {
			return;
		};

		let Some(handle_id) = message.handle_id else {
			return;
		};
		let Some(chat_id) = message.chat_id else {
			return;
		};

		if handles.is_group_chat(chat_id) {
			return;
		}

		let word_count = text.split_whitespace().count();
		if word_count < 10 {
			return;
		}

		if let Some(handles_list) = handles.get_chat_handles(chat_id) {
			if let Some(handle) = handles_list.iter().find(|h| h.rowid == handle_id as i64) {
				let year_stats = self.longest_messages.entry(year).or_default();
				let entry = year_stats
					.entry(handle.normalized_id.clone())
					.or_insert_with(|| (text.clone(), word_count));

				if word_count > entry.1 {
					*entry = (text.clone(), word_count);
				}

				if year != 0 {
					self.update_longest_message(0, message, handles);
				}
			}
		}
	}

	pub fn get_word_and_emoji_counts(&self, limit: usize) -> HashMap<i32, WordAndEmojiCount> {
		let start = Instant::now();

		let convert_and_sort = |map: &HashMap<String, u32>| -> Vec<Item> {
			let mut vec: Vec<_> = map
				.iter()
				.map(|(k, v)| Item { key: k.clone(), count: *v as i32 })
				.collect();
			vec.sort_by(|a, b| b.count.cmp(&a.count));
			vec.truncate(limit);
			vec
		};

		let result = self
			.word_counts
			.iter()
			.map(|(&year, (sent_words, received_words))| {
				let (sent_emojis, received_emojis) = &self.emoji_counts[&year];
				(
					year,
					WordAndEmojiCount {
						words: Count {
							sent: convert_and_sort(sent_words),
							received: convert_and_sort(received_words)
						},
						emojis: Count {
							sent: convert_and_sort(sent_emojis),
							received: convert_and_sort(received_emojis)
						}
					}
				)
			})
			.collect();

		self.timings.borrow_mut().words_emoji_time += start.elapsed();
		result
	}

	pub fn get_reaction_stats(
		&self, handles: &Handles, contacts: &Contacts, limit: usize
	) -> HashMap<i32, Vec<MessageReactionSummary>> {
		let start = Instant::now();

		let result = self
			.reaction_counts
			.iter()
			.map(|(&year, counts)| {
				let mut messages: Vec<(String, i32)> = counts
					.iter()
					.map(|(guid, &count)| (guid.clone(), count))
					.collect();

				messages.sort_by(|a, b| b.1.cmp(&a.1));
				messages.truncate(limit);

				let empty_details: HashMap<String, (String, i32)> = HashMap::new();
				let empty_reactions: HashMap<String, (String, i32, ReactionCounts)> =
					HashMap::new();

				let year_details = self.message_details.get(&year).unwrap_or(&empty_details);
				let year_reactions = self.reaction_details.get(&year).unwrap_or(&empty_reactions);

				let summaries = messages
					.into_iter()
					.filter_map(|(guid, total_count)| {
						year_details.get(&guid).and_then(|(content, chat_id)| {
							year_reactions
								.get(&guid)
								.map(|(_, _, counts)| MessageReactionSummary {
									message_guid: guid,
									message_content: content.clone(),
									chat_id: *chat_id,
									name: handles.get_chat_name(*chat_id, contacts),
									total_count,
									reaction_counts: *counts
								})
						})
					})
					.collect();

				(year, summaries)
			})
			.collect();

		self.timings.borrow_mut().reactions_time += start.elapsed();
		result
	}

	pub fn get_most_sent(&self) -> HashMap<i32, Item> {
		let start = Instant::now();
		let result = self
			.most_sent
			.iter()
			.map(|(&year, texts)| {
				let mut sorted: Vec<Item> = texts
					.iter()
					.filter(|(text, _)| !text.is_empty())
					.map(|(text, &count)| Item { key: text.clone(), count })
					.collect();

				sorted.sort_by(|a, b| b.count.cmp(&a.count).then_with(|| a.key.cmp(&b.key)));

				(
					year,
					sorted
						.into_iter()
						.next()
						.unwrap_or(Item { key: String::new(), count: 0 })
				)
			})
			.collect();
		self.timings.borrow_mut().top_sent_time += start.elapsed();
		result
	}

	pub fn get_yearly_counts(&self) -> &HashMap<i32, MessageCount> {
		let start = Instant::now();
		self.timings.borrow_mut().year_time += start.elapsed();
		&self.yearly_counts
	}

	pub fn get_monthly_stats(&self) -> &HashMap<i32, Vec<MessageCount>> {
		let start = Instant::now();
		self.timings.borrow_mut().month_time += start.elapsed();
		&self.monthly_stats
	}

	pub fn get_weekday_stats(&self) -> &HashMap<i32, Vec<MessageCount>> {
		let start = Instant::now();
		self.timings.borrow_mut().weekday_time += start.elapsed();
		&self.weekday_stats
	}

	pub fn get_hourly_stats(&self) -> &HashMap<i32, Vec<MessageCount>> {
		let start = Instant::now();
		self.timings.borrow_mut().hour_time += start.elapsed();
		&self.hourly_stats
	}

	pub fn get_chat_stats(
		&self, messages: &[Message], contacts: &Contacts, handles: &Handles, limit: usize
	) -> HashMap<
		i32,
		(
			TopChatsResult,
			TopChatsResult,
			TopChatsResult,
			TopTextersByChat
		)
	> {
		let start = Instant::now();

		let result = self
			.chat_stats
			.iter()
			.map(|(&year, stats)| {
				let top_group = self.get_top_chats(year, limit, true);
				let top_individual = self.get_top_chats(year, limit, false);
				let most_active_group_chat_id = stats
					.values()
					.filter(|c| c.is_group_chat)
					.max_by_key(|c| c.sent)
					.map_or(0, |c| c.chat_id);

				let top_down_bad = self.get_top_down_bad_chats(year, 1);
				let year_messages: Vec<&Message> = messages
					.iter()
					.filter(|m| year == 0 || m.time().year() == year as i16)
					.collect();

				let top_texters = StatsAccumulator::get_top_texters_by_chat(
					&year_messages,
					most_active_group_chat_id,
					contacts,
					handles,
					limit
				);

				(year, (top_group, top_individual, top_down_bad, top_texters))
			})
			.collect();

		self.timings.borrow_mut().chat_stats_time += start.elapsed();
		result
	}

	pub fn get_left_on_read(
		&self, handles: &Handles, contacts: &Contacts
	) -> HashMap<i32, MessagesLeftOnRead> {
		let start = Instant::now();
		let mut year_stats = HashMap::new();

		for (&year, chat_stats) in &self.left_on_read_stats {
			let mut stats = MessagesLeftOnRead::default();

			for (&chat_id, &(left, ignored)) in chat_stats {
				if left > 0 || ignored > 0 {
					stats.totals.left_on_read += left;
					stats.totals.ignored_by_me += ignored;

					stats.by_chat.push(ChatLeftOnRead {
						name: handles.get_chat_name(chat_id, contacts),
						chat_id,
						left_on_read: left,
						ignored_by_me: ignored
					});
				}
			}

			if !stats.by_chat.is_empty() {
				stats
					.by_chat
					.sort_by(|a, b| b.left_on_read.cmp(&a.left_on_read));
				let top_left_on_read = stats.by_chat.first().cloned();

				stats
					.by_chat
					.sort_by(|a, b| b.ignored_by_me.cmp(&a.ignored_by_me));
				let top_ignored_by_me = stats.by_chat.first().cloned();

				stats.by_chat = vec![top_left_on_read, top_ignored_by_me]
					.into_iter()
					.flatten()
					.collect();

				year_stats.insert(year, stats);
			}
		}

		self.timings.borrow_mut().left_on_read_time += start.elapsed();
		year_stats
	}

	fn get_top_chats(&self, year: i32, limit: usize, is_group_chat: bool) -> TopChatsResult {
		let year_stats = match self.chat_stats.get(&year) {
			Some(stats) => stats,
			None => return TopChatsResult::default()
		};

		let filtered_chats: Vec<&RawChats> = year_stats
			.values()
			.filter(|chat| chat.is_group_chat == is_group_chat)
			.collect();

		let mut sent_indices: Vec<_> = filtered_chats
			.iter()
			.enumerate()
			.filter(|(_, chat)| chat.sent > 0)
			.map(|(i, chat)| (i, chat.sent))
			.collect();
		sent_indices.sort_by(|a, b| b.1.cmp(&a.1));
		sent_indices.truncate(limit);

		let mut received_indices: Vec<_> = filtered_chats
			.iter()
			.enumerate()
			.filter(|(_, chat)| chat.received > 0)
			.map(|(i, chat)| (i, chat.received))
			.collect();
		received_indices.sort_by(|a, b| b.1.cmp(&a.1));
		received_indices.truncate(limit);

		let mut all_indices: Vec<usize> = sent_indices.iter().map(|(i, _)| *i).collect();
		all_indices.extend(received_indices.iter().map(|(i, _)| *i));
		all_indices.sort_unstable();
		all_indices.dedup();

		let combined_chats: Vec<Chat> = all_indices
			.into_iter()
			.map(|i| {
				let raw = filtered_chats[i];
				Chat {
					chat_id: raw.chat_id,
					name: raw.name.clone(),
					sent: raw.sent,
					received: raw.received,
					is_group_chat: raw.is_group_chat,
					avatar: raw.avatar.as_deref().and_then(Contact::resize_avatar)
				}
			})
			.collect();

		TopChatsResult {
			total_conversations: filtered_chats.len() as i32,
			chats: combined_chats
		}
	}

	fn get_top_down_bad_chats(&self, year: i32, limit: usize) -> TopChatsResult {
		let year_stats = match self.chat_stats.get(&year) {
			Some(stats) => stats,
			None => return TopChatsResult::default()
		};

		let filtered_chats: Vec<&RawChats> = year_stats
			.values()
			.filter(|chat| {
				!chat.is_group_chat &&
					(chat.down_bad_stats.sent > 0 || chat.down_bad_stats.received > 0)
			})
			.collect();

		let mut sent_indices: Vec<_> = filtered_chats
			.iter()
			.enumerate()
			.filter(|(_, chat)| chat.down_bad_stats.sent > 0)
			.map(|(i, chat)| (i, chat.down_bad_stats.sent))
			.collect();
		sent_indices.sort_by(|a, b| b.1.cmp(&a.1));
		sent_indices.truncate(limit);

		let mut received_indices: Vec<_> = filtered_chats
			.iter()
			.enumerate()
			.filter(|(_, chat)| chat.down_bad_stats.received > 0)
			.map(|(i, chat)| (i, chat.down_bad_stats.received))
			.collect();
		received_indices.sort_by(|a, b| b.1.cmp(&a.1));
		received_indices.truncate(limit);

		let mut all_indices: Vec<usize> = sent_indices.iter().map(|(i, _)| *i).collect();
		all_indices.extend(received_indices.iter().map(|(i, _)| *i));
		all_indices.sort_unstable();
		all_indices.dedup();

		let combined_chats: Vec<Chat> = all_indices
			.into_iter()
			.map(|i| {
				let raw = filtered_chats[i];
				Chat {
					chat_id: raw.chat_id,
					name: raw.name.clone(),
					sent: raw.down_bad_stats.sent,
					received: raw.down_bad_stats.received,
					is_group_chat: raw.is_group_chat,
					avatar: raw.avatar.as_deref().and_then(Contact::resize_avatar)
				}
			})
			.collect();

		TopChatsResult {
			total_conversations: filtered_chats.len() as i32,
			chats: combined_chats
		}
	}

	fn get_top_texters_by_chat(
		messages: &[&Message], chat_id: i32, contacts: &Contacts, handles: &Handles, limit: usize
	) -> TopTextersByChat {
		let mut handle_counts: HashMap<String, i32> = HashMap::new();

		for message in messages {
			if message.chat_id != Some(chat_id) {
				continue;
			}

			if message.is_from_me {
				*handle_counts.entry("me".to_string()).or_insert(0) += 1;
			} else if let Some(handle_id) = message.handle_id {
				if let Some(handles_list) = handles.get_chat_handles(chat_id) {
					if let Some(handle) = handles_list.iter().find(|h| h.rowid == handle_id as i64)
					{
						*handle_counts
							.entry(handle.normalized_id.clone())
							.or_insert(0) += 1;
					}
				}
			}
		}

		let mut top_texters: Vec<(String, i32, String, Option<&Contact>)> = handle_counts
			.into_iter()
			.map(|(handle_id, count)| {
				if handle_id == "me" {
					("You".to_string(), count, "me".to_string(), None)
				} else {
					let contact = contacts.lookup(&handle_id);
					(
						contact.map_or_else(|| handle_id.clone(), |c| c.display_name.clone()),
						count,
						handle_id,
						contact
					)
				}
			})
			.collect();

		top_texters.sort_by(|a, b| b.1.cmp(&a.1));
		top_texters.truncate(limit);

		let top_texters = top_texters
			.into_iter()
			.map(|(name, count, handle_id, contact)| TopTexter {
				name,
				message_count: count,
				avatar: contact
					.and_then(|c| c.avatar.as_deref())
					.and_then(Contact::resize_avatar),
				handle_id
			})
			.collect();

		TopTextersByChat {
			chat_id,
			name: handles.get_chat_name(chat_id, contacts),
			top_texters
		}
	}

	pub fn get_average_per_day(&self) -> HashMap<i32, Average> {
		let start = Instant::now();

		let averages = self
			.message_counts
			.iter()
			.filter_map(|(&year, counts)| {
				let first_date = *self.first_message_dates.get(&year)?;
				let last_date = *self.last_message_dates.get(&year)?;

				let days = if year == 0 {
					let total_days =
						(last_date - first_date) as f32 / (24.0 * 60.0 * 60.0 * 1000.0);
					total_days.max(1.0)
				} else {
					365.0
				};

				Some((
					year,
					Average {
						sent: counts.sent as f32 / days,
						received: counts.received as f32 / days
					}
				))
			})
			.collect();

		println!(
			"average_messages_per_day elapsed time = {:?}",
			start.elapsed()
		);
		averages
	}

	pub const fn get_character_counts(&self) -> &HashMap<i32, MessageCount> {
		&self.character_counts
	}

	pub fn get_top_user_by_slurs(&self, year: i32, contacts: &Contacts) -> Option<Chat> {
		let start = Instant::now();
		let result = {
			let year_counts = self.slur_counts.get(&year)?;
			if year_counts.is_empty() {
				return None;
			}

			let top_user = year_counts.iter().max_by_key(|(_, &count)| count)?;
			let contact = contacts.lookup(top_user.0);

			Some(Chat {
				chat_id: 0,
				name: contact.map_or_else(|| top_user.0.clone(), |c| c.display_name.clone()),
				sent: 0,
				received: *top_user.1,
				is_group_chat: false,
				avatar: contact
					.and_then(|c| c.avatar.as_deref())
					.and_then(Contact::resize_avatar)
			})
		};
		self.timings.borrow_mut().slurs_time += start.elapsed();
		result
	}

	pub fn get_top_group_chat_by_slurs(
		&self, year: i32, contacts: &Contacts, handles: &Handles
	) -> Option<TopTextersByChat> {
		let start = Instant::now();
		let result = {
			let year_stats = self.group_chat_slur_stats.get(&year)?;
			if year_stats.is_empty() {
				return None;
			}

			let top_chat = year_stats
				.iter()
				.max_by_key(|(_, user_stats)| user_stats.values().sum::<i32>())?;

			let chat_id = *top_chat.0;
			let user_stats = top_chat.1;

			let mut top_texters: Vec<TopTexter> = user_stats
				.iter()
				.map(|(handle_id, &count)| {
					let contact = contacts.lookup(handle_id);
					TopTexter {
						name: contact.map_or_else(|| handle_id.clone(), |c| c.display_name.clone()),
						message_count: count,
						handle_id: handle_id.clone(),
						avatar: contact
							.and_then(|c| c.avatar.as_deref())
							.and_then(Contact::resize_avatar)
					}
				})
				.collect();

			top_texters.sort_by(|a, b| b.message_count.cmp(&a.message_count));
			top_texters.truncate(5);

			Some(TopTextersByChat {
				chat_id,
				name: handles.get_chat_name(chat_id, contacts),
				top_texters
			})
		};
		self.timings.borrow_mut().group_chat_slurs_time += start.elapsed();
		result
	}

	pub fn get_response_time_stats(
		&self, year: i32, contacts: &Contacts
	) -> Option<(ResponseTimeStats, ResponseTimeStats)> {
		let start = Instant::now();

		let year_stats = self.response_time_stats.get(&year)?;
		if year_stats.is_empty() {
			self.timings.borrow_mut().response_time += start.elapsed();
			return None;
		}

		let thresholds = [100, 50, 25];
		let mut selected_threshold = 0;
		let mut response_times = Vec::new();

		for &threshold in &thresholds {
			response_times = year_stats
				.iter()
				.map(|(handle_id, &(total_time, count))| {
					let average = total_time as f64 / count as f64;
					(handle_id.clone(), average, count)
				})
				.filter(|(_, _, count)| *count >= threshold)
				.collect();

			if response_times.len() >= 5 {
				selected_threshold = threshold;
				break;
			}
		}

		if response_times.is_empty() {
			response_times = year_stats
				.iter()
				.map(|(handle_id, &(total_time, count))| {
					let average = total_time as f64 / count as f64;
					(handle_id.clone(), average, count)
				})
				.collect();
		}

		if response_times.is_empty() {
			return None;
		}

		println!(
			"Using threshold of {} messages with {} people for response time stats",
			selected_threshold,
			response_times.len()
		);

		response_times.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());

		let create_stats = |handle_id: &str, avg_time: f64| {
			let contact = contacts.lookup(handle_id);
			ResponseTimeStats {
				name: contact.map_or_else(|| handle_id.to_string(), |c| c.display_name.clone()),
				handle_id: handle_id.to_string(),
				average_time_in_seconds: avg_time as i64,
				avatar: contact
					.and_then(|c| c.avatar.as_deref())
					.and_then(Contact::resize_avatar)
			}
		};

		let fastest = create_stats(&response_times[0].0, response_times[0].1);
		let slowest = create_stats(
			&response_times[response_times.len() - 1].0,
			response_times[response_times.len() - 1].1
		);

		self.timings.borrow_mut().response_time += start.elapsed();
		Some((fastest, slowest))
	}

	pub fn get_longest_message(
		&self, year: i32, contacts: &Contacts
	) -> Option<LongestMessageStats> {
		let start = Instant::now();

		let year_stats = self.longest_messages.get(&year)?;
		if year_stats.is_empty() {
			self.timings.borrow_mut().message_length_time += start.elapsed();
			return None;
		}

		let longest = year_stats.iter().max_by_key(|(_, (_, count))| count)?;

		let contact = contacts.lookup(longest.0);
		let stats = LongestMessageStats {
			name: contact.map_or_else(|| longest.0.clone(), |c| c.display_name.clone()),
			handle_id: longest.0.clone(),
			message: longest.1 .0.clone(),
			word_count: longest.1 .1 as i32,
			avatar: contact
				.and_then(|c| c.avatar.as_deref())
				.and_then(Contact::resize_avatar)
		};

		self.timings.borrow_mut().message_length_time += start.elapsed();
		Some(stats)
	}

	pub fn get_top_reactioners(
		&self, year: i32, contacts: &Contacts
	) -> Option<(ReactionerStats, ReactionerStats)> {
		let start = Instant::now();
		let year_haters = self.hater_stats.get(&year)?;
		let year_glazers = self.glazer_stats.get(&year)?;

		if year_haters.is_empty() && year_glazers.is_empty() {
			return None;
		}

		let top_hater = year_haters
			.iter()
			.max_by_key(|(_, &count)| count)
			.map(|(handle_id, &count)| {
				let contact = contacts.lookup(handle_id);
				ReactionerStats {
					name: contact.map_or_else(|| handle_id.clone(), |c| c.display_name.clone()),
					handle_id: handle_id.clone(),
					reaction_count: count,
					avatar: contact
						.and_then(|c| c.avatar.as_deref())
						.and_then(Contact::resize_avatar)
				}
			})
			.unwrap_or_default();

		let top_glazer = year_glazers
			.iter()
			.max_by_key(|(_, &count)| count)
			.map(|(handle_id, &count)| {
				let contact = contacts.lookup(handle_id);
				ReactionerStats {
					name: contact.map_or_else(|| handle_id.clone(), |c| c.display_name.clone()),
					handle_id: handle_id.clone(),
					reaction_count: count,
					avatar: contact
						.and_then(|c| c.avatar.as_deref())
						.and_then(Contact::resize_avatar)
				}
			})
			.unwrap_or_default();

		self.timings.borrow_mut().reactionner_time += start.elapsed();
		Some((top_hater, top_glazer))
	}

	fn update_phrase_stats(
		stats_map: &mut HashMap<i32, HashMap<String, i32>>, year: i32, message: &Message,
		handles: &Handles, is_phrase_fn: impl Fn(&str) -> bool
	) {
		if message.is_from_me {
			return;
		}

		let Some(text) = &message.text else { return };
		let Some(handle_id) = message.handle_id else {
			return;
		};
		let Some(chat_id) = message.chat_id else {
			return;
		};

		if handles.is_group_chat(chat_id) {
			return;
		}

		let text = text.to_lowercase();
		let words: Vec<_> = text.split_whitespace().collect();

		// Look for phrases of different lengths (1-4 words)
		let mut unique_matches = HashSet::new();
		for window_size in 1..=4 {
			for window in words.windows(window_size) {
				let phrase = window.join(" ");
				if is_phrase_fn(&phrase) {
					unique_matches.insert(phrase);
				}
			}
		}

		let phrase_count = unique_matches.len();

		if phrase_count > 0 {
			if let Some(handles_list) = handles.get_chat_handles(chat_id) {
				if let Some(handle) = handles_list.iter().find(|h| h.rowid == handle_id as i64) {
					let year_stats = stats_map.entry(year).or_default();
					*year_stats.entry(handle.normalized_id.clone()).or_default() +=
						phrase_count as i32;

					if year != 0 {
						let all_time = stats_map.entry(0).or_default();
						*all_time.entry(handle.normalized_id.clone()).or_default() +=
							phrase_count as i32;
					}
				}
			}
		}
	}

	fn get_top_phrase_user(
		year: i32, contacts: &Contacts, stats_map: &HashMap<i32, HashMap<String, i32>>
	) -> Option<PhraseStats> {
		let year_stats = stats_map.get(&year)?;
		if year_stats.is_empty() {
			return None;
		}

		let top_user = year_stats.iter().max_by_key(|(_, &count)| count)?;

		let contact = contacts.lookup(top_user.0);
		Some(PhraseStats {
			name: contact.map_or_else(|| top_user.0.clone(), |c| c.display_name.clone()),
			handle_id: top_user.0.clone(),
			count: *top_user.1,
			avatar: contact
				.and_then(|c| c.avatar.as_deref())
				.and_then(Contact::resize_avatar)
		})
	}

	pub fn get_top_favor_asker(&self, year: i32, contacts: &Contacts) -> Option<PhraseStats> {
		Self::get_top_phrase_user(year, contacts, &self.favor_stats)
	}

	pub fn get_top_freaky_texter(&self, year: i32, contacts: &Contacts) -> Option<PhraseStats> {
		Self::get_top_phrase_user(year, contacts, &self.freaky_stats)
	}

	fn update_double_text_stats(&mut self, year: i32, message: &Message, handles: &Handles) {
		if message.is_from_me {
			if let Some(chat_id) = message.chat_id {
				let year_last_messages = self.last_message_times.entry(year).or_default();
				let chat_messages = year_last_messages
					.entry(chat_id)
					.or_insert_with(|| (0, String::new(), false));
				*chat_messages = (message.date, String::new(), false);
			}
			return;
		}

		let Some(chat_id) = message.chat_id else {
			return;
		};
		if handles.is_group_chat(chat_id) {
			return;
		}
		let Some(handle_id) = message.handle_id else {
			return;
		};
		let Some(handles_list) = handles.get_chat_handles(chat_id) else {
			return;
		};
		let Some(handle) = handles_list.iter().find(|h| h.rowid == handle_id as i64) else {
			return;
		};
		let normalized_id = handle.normalized_id.clone();

		let year_last_messages = self.last_message_times.entry(year).or_default();
		let chat_messages = year_last_messages
			.entry(chat_id)
			.or_insert_with(|| (0, String::new(), false));

		if !chat_messages.1.is_empty() && chat_messages.1 == normalized_id {
			let (last_time, ..) = *chat_messages;
			let time_diff = message.date - last_time;
			let double_text_threshold = 20 * 60 * 1_000_000_000i64; // 20 minutes

			// Only count if they send another message after 20 minutes without a reply
			if time_diff > double_text_threshold {
				let year_stats = self.double_text_stats.entry(year).or_default();
				*year_stats.entry(normalized_id.clone()).or_default() += 1;

				if year != 0 {
					let all_time = self.double_text_stats.entry(0).or_default();
					*all_time.entry(normalized_id.clone()).or_default() += 1;
				}
			}
		}

		*chat_messages = (message.date, normalized_id, false);
	}

	pub fn get_top_double_texter(&self, year: i32, contacts: &Contacts) -> Option<DoubleTextStats> {
		let year_stats = self.double_text_stats.get(&year)?;
		if year_stats.is_empty() {
			return None;
		}

		let top_double_texter = year_stats.iter().max_by_key(|(_, &count)| count)?;

		let contact = contacts.lookup(top_double_texter.0);
		Some(DoubleTextStats {
			name: contact.map_or_else(|| top_double_texter.0.clone(), |c| c.display_name.clone()),
			handle_id: top_double_texter.0.clone(),
			double_text_count: *top_double_texter.1,
			avatar: contact
				.and_then(|c| c.avatar.as_deref())
				.and_then(Contact::resize_avatar)
		})
	}

	fn update_group_chat_slur_counts(&mut self, year: i32, message: &Message, handles: &Handles) {
		if message.is_from_me {
			return;
		}

		let Some(text) = &message.text else { return };
		if text.is_empty() {
			return;
		};

		let Some(handle_id) = message.handle_id else {
			return;
		};
		let Some(chat_id) = message.chat_id else {
			return;
		};

		if !handles.is_group_chat(chat_id) {
			return;
		}

		let contains_slur = text.split_whitespace().any(is_slur);

		if contains_slur {
			if let Some(handles_list) = handles.get_chat_handles(chat_id) {
				if let Some(handle) = handles_list.iter().find(|h| h.rowid == handle_id as i64) {
					let year_stats = self.group_chat_slur_stats.entry(year).or_default();
					let chat_stats = year_stats.entry(chat_id).or_default();
					*chat_stats.entry(handle.normalized_id.clone()).or_default() += 1;

					if year != 0 {
						let all_time = self.group_chat_slur_stats.entry(0).or_default();
						let chat_stats = all_time.entry(chat_id).or_default();
						*chat_stats.entry(handle.normalized_id.clone()).or_default() += 1;
					}
				}
			}
		}
	}

	pub fn get_worst_send_received_ratio(
		&self, year: i32, contacts: &Contacts, handles: &Handles
	) -> Option<SendReceivedRatioStats> {
		let start = Instant::now();
		let year_stats = self.send_received_ratios.get(&year)?;

		let thresholds = [100, 50, 25];
		let mut selected_threshold = 0;
		let mut chat_ratios = Vec::new();

		for &threshold in &thresholds {
			chat_ratios = year_stats
				.iter()
				.filter(|(_, &(sent, received))| sent >= 5 && (sent + received) >= threshold)
				.map(|(&chat_id, &(sent, received))| {
					let ratio = if received == 0 {
						f32::INFINITY
					} else {
						sent as f32 / received as f32
					};
					(chat_id, sent, received, ratio)
				})
				.collect();

			if chat_ratios.len() >= 5 {
				selected_threshold = threshold;
				break;
			}
		}

		if chat_ratios.is_empty() {
			chat_ratios = year_stats
				.iter()
				.filter(|(_, &(sent, received))| sent >= 5 && received > 0)
				.map(|(&chat_id, &(sent, received))| {
					let ratio = sent as f32 / received as f32;
					(chat_id, sent, received, ratio)
				})
				.collect();
		}

		if chat_ratios.is_empty() {
			return None;
		}

		println!(
			"Using threshold of {} messages with {} chats for send/received ratio stats",
			selected_threshold,
			chat_ratios.len()
		);

		let worst_ratio = chat_ratios
			.into_iter()
			.min_by(|a, b| a.3.partial_cmp(&b.3).unwrap())?;

		let (chat_id, sent, received, _) = worst_ratio;

		let handle_id = if let Some(handles_list) = handles.get_chat_handles(chat_id) {
			handles_list.first().map(|h| h.normalized_id.clone())
		} else {
			None
		}
		.unwrap_or_else(|| handles.get_chat_name(chat_id, contacts));

		let contact = contacts.lookup(&handle_id);

		self.timings.borrow_mut().send_received_ratio_time += start.elapsed();
		Some(SendReceivedRatioStats {
			name: contact.map_or_else(|| handle_id.clone(), |c| c.display_name.clone()),
			handle_id,
			sent,
			received,
			avatar: contact
				.and_then(|c| c.avatar.as_deref())
				.and_then(Contact::resize_avatar)
		})
	}

	fn update_send_received_ratio(&mut self, year: i32, message: &Message, handles: &Handles) {
		let Some(chat_id) = message.chat_id else {
			return;
		};
		if handles.is_group_chat(chat_id) {
			return;
		};

		let year_stats = self.send_received_ratios.entry(year).or_default();
		let (sent, received) = year_stats.entry(chat_id).or_insert((0, 0));

		if message.is_from_me {
			*sent += 1;
		} else {
			*received += 1;
		}

		if year != 0 {
			let start = Instant::now();
			self.update_send_received_ratio(0, message, handles);
			self.timings.borrow_mut().send_received_ratio_time += start.elapsed();
		}
	}

	pub fn get_realest_friend(&self, year: i32, contacts: &Contacts) -> Option<PhraseStats> {
		let year_stats = self.realest_stats.get(&year)?;
		if year_stats.is_empty() {
			return None;
		}

		let top_realest = year_stats.iter().max_by_key(|(_, &count)| count)?;

		let contact = contacts.lookup(top_realest.0);
		Some(PhraseStats {
			name: contact.map_or_else(|| top_realest.0.clone(), |c| c.display_name.clone()),
			handle_id: top_realest.0.clone(),
			count: *top_realest.1,
			avatar: contact
				.and_then(|c| c.avatar.as_deref())
				.and_then(Contact::resize_avatar)
		})
	}
}
