use std::collections::HashMap;
use std::fs;
use std::path::Path;
use std::sync::{Mutex, OnceLock};

use base64::engine::general_purpose::STANDARD as base64;
use base64::Engine;
use image::GenericImageView;
use phonenumber::country::Id;
use phonenumber::Mode;
use regex::Regex;
use rusqlite::{Connection, Params, Statement};

use crate::from_query::{FromQuery, QueryAll};
use crate::AnalyzerResult;

const MAX_AVATAR_SIZE: u32 = 125;

static NON_DIGITS: OnceLock<Regex> = OnceLock::new();
static AVATAR_CACHE: OnceLock<Mutex<HashMap<Vec<u8>, Vec<u8>>>> = OnceLock::new();

#[derive(Debug, Clone, serde::Serialize)]
pub struct Contact {
	pub id: i64,
	pub display_name: String,
	pub phone_numbers: Vec<String>,
	pub email: Option<String>,
	pub avatar: Option<Vec<u8>>,
	pub image_hash: Option<String>
}

impl Contact {
	fn get_query(conn: &Connection) -> AnalyzerResult<Statement<'_>> {
		match conn.prepare(
			"SELECT 
				ZABCDRECORD.Z_PK,
				ZABCDRECORD.ZFIRSTNAME,
				ZABCDRECORD.ZLASTNAME,
				ZABCDRECORD.ZTHUMBNAILIMAGEDATA,
				ZABCDRECORD.ZIMAGEDATA,
				ZABCDRECORD.ZIMAGEHASH,
				GROUP_CONCAT(ZABCDPHONENUMBER.ZFULLNUMBER) as phone_numbers,
				ZABCDEMAILADDRESS.ZADDRESSNORMALIZED
			FROM ZABCDRECORD
			LEFT JOIN ZABCDPHONENUMBER ON ZABCDRECORD.Z_PK = ZABCDPHONENUMBER.ZOWNER
			LEFT JOIN ZABCDEMAILADDRESS ON ZABCDRECORD.Z_PK = ZABCDEMAILADDRESS.ZOWNER
			WHERE ZABCDRECORD.ZFIRSTNAME IS NOT NULL 
			GROUP BY ZABCDRECORD.Z_PK
			ORDER BY ZABCDRECORD.Z_PK ASC"
		) {
			Ok(stmt) => Ok(stmt),
			Err(_) => Ok(conn.prepare(
				"SELECT 
					ZABCDRECORD.Z_PK,
					ZABCDRECORD.ZFIRSTNAME,
					ZABCDRECORD.ZLASTNAME,
					NULL as ZTHUMBNAILIMAGEDATA,
					NULL as ZIMAGEDATA,
					NULL as ZIMAGEHASH,
					GROUP_CONCAT(ZABCDPHONENUMBER.ZFULLNUMBER) as phone_numbers,
					ZABCDEMAILADDRESS.ZADDRESSNORMALIZED
				FROM ZABCDRECORD
				LEFT JOIN ZABCDPHONENUMBER ON ZABCDRECORD.Z_PK = ZABCDPHONENUMBER.ZOWNER
				LEFT JOIN ZABCDEMAILADDRESS ON ZABCDRECORD.Z_PK = ZABCDEMAILADDRESS.ZOWNER
				WHERE ZABCDRECORD.ZFIRSTNAME IS NOT NULL 
				GROUP BY ZABCDRECORD.Z_PK
				ORDER BY ZABCDRECORD.Z_PK ASC"
			)?)
		}
	}

	fn strip_macos_header(data: &[u8]) -> Option<Vec<u8>> {
		if data.is_empty() {
			return None;
		}
		// Skip the first byte which is a header byte in macOS contacts
		let data = &data[1..];
		Some(data.to_vec())
	}

	fn process_image_data(data: Option<Vec<u8>>) -> (Option<Vec<u8>>, Option<String>) {
		match data {
			Some(data) if data.len() > 38 => {
				if let Some(processed) = Self::strip_macos_header(&data) {
					(Some(processed), None)
				} else {
					(None, None)
				}
			}
			Some(data) if data.len() == 38 => {
				// Try to extract UUID
				String::from_utf8(data[1..37].to_vec()).map_or_else(
					|_| (Self::strip_macos_header(&data), None),
					|uuid| (None, Some(uuid))
				)
			}
			Some(data) => (Self::strip_macos_header(&data), None),
			None => (None, None)
		}
	}

	fn get_avatar_data(row: &rusqlite::Row<'_>) -> (Option<Vec<u8>>, Option<String>) {
		let thumbnail: Option<Vec<u8>> = row.get("ZTHUMBNAILIMAGEDATA").unwrap_or_default();

		let (avatar, hash) = Self::process_image_data(thumbnail);
		if avatar.is_some() {
			return (avatar, hash);
		}

		let image_data: Option<Vec<u8>> = row.get("ZIMAGEDATA").unwrap_or_default();

		Self::process_image_data(image_data)
	}

	pub fn resize_avatar(avatar_bytes: &[u8]) -> Option<Vec<u8>> {
		let cache = AVATAR_CACHE.get_or_init(|| Mutex::new(HashMap::new()));
		let mut cache = cache.lock().unwrap();

		// Return cached version if it exists
		if let Some(compressed) = cache.get(avatar_bytes) {
			return Some(compressed.clone());
		}

		if avatar_bytes.is_empty() {
			return None;
		}

		// Compression logic with smaller target size
		let compressed = {
			let img = image::load_from_memory(avatar_bytes)
				.or_else(|_| image::load_from_memory(&avatar_bytes[1..]))
				.map_err(|e| {
					println!("Failed to load avatar image: {}", e);
					e
				})
				.ok()?;

			// Always resize to smaller dimensions
			let target_size = MAX_AVATAR_SIZE;
			let (width, height) = img.dimensions();
			let ratio = width as f32 / height as f32;
			let (new_width, new_height) = if ratio > 1.0 {
				(target_size, (target_size as f32 / ratio) as u32)
			} else {
				((target_size as f32 * ratio) as u32, target_size)
			};

			let resized = image::imageops::resize(
				&img.to_rgb8(),
				new_width,
				new_height,
				image::imageops::FilterType::Triangle
			);

			let mut buffer = Vec::new();
			let mut encoder = image::codecs::jpeg::JpegEncoder::new_with_quality(&mut buffer, 60);
			encoder
				.encode(
					&resized,
					new_width,
					new_height,
					image::ExtendedColorType::Rgb8
				)
				.map_err(|e| {
					println!("Failed to encode avatar as JPEG: {}", e);
					e
				})
				.ok()?;
			buffer
		};

		println!("Compressed avatar size: {}", compressed.len());

		if compressed.len() >= 50 {
			cache.insert(avatar_bytes.to_vec(), compressed.clone());
			Some(compressed)
		} else {
			None
		}
	}
}

pub struct Contacts {
	by_phone: HashMap<String, Contact>,
	by_email: HashMap<String, Contact>
}

impl Contacts {
	pub fn new(connections: &[Connection], address_book_path: &Path) -> AnalyzerResult<Self> {
		let mut by_phone = HashMap::new();
		let mut by_email = HashMap::new();

		let image_hash_lookup = build_image_hash_lookup(address_book_path)?;

		let mut contacts = Self::get_contacts(connections)?;

		for contact in &mut contacts {
			if contact.avatar.is_none() {
				if let Some(hash) = &contact.image_hash {
					contact.avatar = image_hash_lookup.get(hash).cloned();
				}
			}
		}

		for contact in contacts {
			for phone in &contact.phone_numbers {
				by_phone.insert(Self::normalize_id(phone), contact.clone());
			}

			if let Some(email) = &contact.email {
				by_email.insert(Self::normalize_id(email), contact.clone());
			}
		}

		Ok(Self { by_phone, by_email })
	}

	pub fn lookup(&self, handle_id: &str) -> Option<&Contact> {
		// Try phone lookup first
		self.by_phone
			.get(&Self::normalize_id(handle_id))
			.or_else(|| self.by_email.get(&Self::normalize_id(handle_id)))
	}

	fn get_contacts(connections: &[Connection]) -> AnalyzerResult<Vec<Contact>> {
		let mut contacts_map: HashMap<i64, Contact> = HashMap::with_capacity(1000);

		for conn in connections {
			let contacts = Contact::query_all(conn, [])?;

			for contact in contacts {
				contacts_map.insert(contact.id, contact);
			}
		}

		let contacts: Vec<Contact> = contacts_map.into_values().collect();
		Ok(contacts)
	}

	pub fn get_non_digits_regex() -> &'static Regex {
		NON_DIGITS.get_or_init(|| Regex::new("[^0-9]").unwrap())
	}

	pub fn normalize_id(id: &str) -> String {
		if id.contains('@') {
			id.to_lowercase()
		} else {
			Self::get_non_digits_regex().replace_all(id, "").to_string()
		}
	}

	fn clean_phone_number(phone: &str) -> String {
		let parsed =
			phonenumber::parse(Some(Id::US), phone).or_else(|_| phonenumber::parse(None, phone));

		match parsed {
			Ok(number) if phonenumber::is_valid(&number) => {
				number.format().mode(Mode::E164).to_string()
			}
			_ => Self::normalize_id(phone)
		}
	}

	fn clean_name(first: &str, last: Option<&str>) -> String {
		match last {
			Some(last) if !last.is_empty() => format!("{} {}", first.trim(), last.trim()),
			_ => first.trim().to_string()
		}
	}
}

fn build_image_hash_lookup(address_book_path: &Path) -> AnalyzerResult<HashMap<String, Vec<u8>>> {
	let mut hash_lookup = HashMap::new();
	let sources_path = address_book_path.join("Sources");

	if !sources_path.exists() {
		return Ok(hash_lookup);
	}

	// Scan all source directories once
	for entry in fs::read_dir(sources_path)?.flatten() {
		if !entry.path().is_dir() {
			continue;
		}

		let support_path = entry
			.path()
			.join(".AddressBook-v22_SUPPORT")
			.join("_EXTERNAL_DATA");

		if !support_path.exists() {
			continue;
		}

		for file in fs::read_dir(&support_path)?.flatten() {
			let hash = file.file_name().to_string_lossy().into_owned();
			if let Ok(data) = fs::read(file.path()) {
				hash_lookup.insert(hash, data);
			}
		}
	}

	Ok(hash_lookup)
}

impl FromQuery for Contact {
	fn from_query<P>(stmt: &mut Statement<'_>, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		let mut contacts = Vec::new();
		let mut rows = stmt.query(params)?;

		while let Some(row) = rows.next()? {
			let first_name: String = row.get("ZFIRSTNAME")?;
			let last_name: Option<String> = row.get("ZLASTNAME").unwrap_or_default();
			let (avatar_data, image_hash) = Self::get_avatar_data(row);

			let phone_numbers = row
				.get::<_, Option<String>>("phone_numbers")
				.unwrap_or_default()
				.map(|phones| {
					phones
						.split(',')
						.map(|p| Contacts::clean_phone_number(p.trim()))
						.collect()
				})
				.unwrap_or_default();

			contacts.push(Contact {
				id: row.get("Z_PK")?,
				display_name: Contacts::clean_name(&first_name, last_name.as_deref()),
				phone_numbers,
				email: row.get("ZADDRESSNORMALIZED").unwrap_or_default(),
				avatar: avatar_data,
				image_hash
			});
		}

		Ok(contacts)
	}
}

impl QueryAll for Contact {
	fn query_all<P>(db: &Connection, params: P) -> AnalyzerResult<Vec<Self>>
	where
		P: Params
	{
		Self::from_query(&mut Self::get_query(db)?, params)
	}
}
